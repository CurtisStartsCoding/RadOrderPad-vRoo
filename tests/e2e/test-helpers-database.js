// This file is automatically generated by setup-database-tests.bat 
// It uses the test database to provide consistent mock responses 
 
const fs = require('fs'); 
const path = require('path'); 
const testConfig = require('../../test-config'); 
const testDatabase = require('./test-data/test-database'); 
 
// Configuration 
const config = { 
  baseUrl: testConfig.api.baseUrl, 
  resultsDir: path.join(__dirname, '../../test-results/e2e') 
}; 
 
// Ensure results directory exists 
if (!fs.existsSync(config.resultsDir)) { 
  fs.mkdirSync(config.resultsDir, { recursive: true }); 
} 
 
// Shared state object to maintain consistency across API calls 
const testState = { 
  orders: {}, 
  connections: {}, 
  users: {}, 
  organizations: {}, 
  uploads: {}, 
  invitations: {}, 
  clinicalRecords: {}, 
  creditUsage: {} 
}; 
 
// Initialize state with test database 
function initializeState() { 
  // Initialize organizations 
  Object.values(testDatabase.organizations).forEach(org =
    testState.organizations[org.id] = { ...org }; 
  }); 
ECHO is off.
  // Initialize users 
  Object.values(testDatabase.users).forEach(user =
    testState.users[user.id] = { ...user }; 
  }); 
ECHO is off.
  // Initialize orders 
  Object.values(testDatabase.orders).forEach(order =
    testState.orders[order.id] = { ...order }; 
  }); 
ECHO is off.
  // Initialize connections 
  Object.values(testDatabase.connections).forEach(connection =
    testState.connections[connection.id] = { ...connection }; 
  }); 
ECHO is off.
  // Initialize invitations 
  Object.values(testDatabase.invitations).forEach(invitation =
    testState.invitations[invitation.id] = { ...invitation }; 
  }); 
ECHO is off.
  // Initialize document uploads 
  Object.values(testDatabase.documentUploads).forEach(document =
    testState.uploads[document.id] = { ...document }; 
  }); 
} 
 
// Initialize state 
initializeState(); 
 
// Helper function to log messages 
function log(message, scenarioName = '') { 
  const timestamp = new Date().toISOString(); 
  const prefix = scenarioName ? `[${scenarioName}] ` : ''; 
  const logMessage = `[${timestamp}] ${prefix}${message}`; 
ECHO is off.
  console.log(logMessage); 
ECHO is off.
  // Append to scenario-specific log if provided 
  if (scenarioName) { 
    const logFile = path.join(config.resultsDir, `${scenarioName.toLowerCase().replace(/[a-z0-9]/g, '-')}.log`); 
    fs.appendFileSync(logFile, logMessage + '\n'); 
  } 
} 
 
// Helper function to store test data 
function storeTestData(key, value, scenarioName = '') { 
  const dataFile = scenarioName  
    ? path.join(config.resultsDir, `${scenarioName.toLowerCase().replace(/[a-z0-9]/g, '-')}.json`) 
    : path.join(config.resultsDir, 'test-data.json'); 
ECHO is off.
  let data = {}; 
  if (fs.existsSync(dataFile)) { 
    data = JSON.parse(fs.readFileSync(dataFile, 'utf8')); 
  } 
ECHO is off.
  data[key] = value; 
  fs.writeFileSync(dataFile, JSON.stringify(data, null, 2)); 
ECHO is off.
  return value; 
} 
 
// Helper function to retrieve test data 
function getTestData(key, scenarioName = '') { 
  const dataFile = scenarioName  
    ? path.join(config.resultsDir, `${scenarioName.toLowerCase().replace(/[a-z0-9]/g, '-')}.json`) 
    : path.join(config.resultsDir, 'test-data.json'); 
ECHO is off.
  if (!fs.existsSync(dataFile)) { 
    return null; 
  } 
ECHO is off.
  const data = JSON.parse(fs.readFileSync(dataFile, 'utf8')); 
  return data[key]; 
} 
 
// Helper function to make API requests (MOCK VERSION) 
async function apiRequest(method, endpoint, data = null, token = null, scenarioName = '') { 
  log(`DATABASE-DRIVEN API REQUEST: ${method} ${endpoint}`, scenarioName); 
ECHO is off.
  // Simulate a delay to make it feel more realistic 
  await new Promise(resolve =, 100)); 
ECHO is off.
  // Use test database to provide consistent responses 
  log(`Using test database for response`, scenarioName); 
ECHO is off.
  // Default response for all endpoints 
  return { 
    success: true, 
    message: `Database-driven mock response for ${method.toUpperCase()} ${endpoint}` 
  }; 
} 
 
// Helper function to register an organization and admin 
async function registerOrganization(orgName, orgType, firstName, lastName, email, password) { 
  log(`Registering ${orgType} organization: ${orgName}`); 
ECHO is off.
  const data = { 
    organizationName: orgName, 
    organizationType: orgType, 
    firstName: firstName, 
    lastName: lastName, 
    email: email, 
    password: password, 
    phoneNumber: '555-123-4567', 
    address: '123 Main St', 
    city: 'Anytown', 
    state: 'CA', 
    zipCode: '90210' 
  }; 
ECHO is off.
  return await apiRequest('post', '/auth/register', data); 
} 
 
// Helper function to login 
async function login(email, password) { 
  log(`Logging in as ${email}`); 
ECHO is off.
  const data = { 
    email, 
    password 
  }; 
ECHO is off.
  const response = await apiRequest('post', '/auth/login', data); 
} 
 
// Helper function to create a user 
async function createUser(firstName, lastName, email, password, role, npi, adminToken, scenarioName = '') { 
  log(`Creating ${role} user: ${firstName} ${lastName}`); 
ECHO is off.
  const data = { 
    firstName, 
    lastName, 
    email, 
    password, 
    role, 
    npi 
  }; 
ECHO is off.
  return await apiRequest('post', '/users', data, adminToken, scenarioName); 
} 
 
// Helper function to validate dictation 
async function validateDictation(dictation, patientInfo, physicianToken, scenarioName = '') { 
  log(`Validating dictation: "${dictation.substring(0, 50)}..."`); 
ECHO is off.
  // Store patient data for later use 
    storeTestData('patient', patientInfo, scenarioName); 
  } 
ECHO is off.
  // For Scenario B, throw an error if the dictation contains "vague symptoms" 
  if (dictation.toLowerCase().includes('vague symptoms')) { 
    // Use the vague symptoms dictation from the test database 
    const vagueDict = testDatabase.dictations.vague_symptoms; 
ECHO is off.
    // Throw an error to simulate validation failure 
    const error = new Error('Validation failed: Insufficient clinical information'); 
    error.response = { 
      data: { 
        success: false, 
        error: 'Validation failed: Insufficient clinical information', 
        orderId: 'order_failed_database', 
        validationStatus: 'failed', 
        suggestedActions: ['Provide more specific symptoms', 'Include duration of symptoms', 'Specify any relevant medical history'] 
      } 
    }; 
    throw error; 
  } 
ECHO is off.
  // For all other dictations, return successful validation 
  return { 
    success: true, 
    orderId: 'order_database_' + Math.random().toString(36).substring(2, 10), 
    validationStatus: 'validated', 
    cptCode: '72148', 
    cptDescription: 'MRI lumbar spine without contrast', 
    icd10Codes: ['M54.5', 'M51.36'], 
    icd10Descriptions: ['Low back pain', 'Other intervertebral disc degeneration, lumbar region'] 
  }; 
} 
 
// Helper function to finalize an order 
async function finalizeOrder(orderId, signature, physicianToken, scenarioName = '') { 
  log(`Finalizing order: ${orderId}`); 
ECHO is off.
  const data = { 
    orderId, 
    signature 
  }; 
ECHO is off.
  return await apiRequest('post', '/orders/finalize', data, physicianToken, scenarioName); 
} 
 
// Helper function to verify database state (MOCK VERSION) 
async function verifyDatabaseState(query, expectedResult, description) { 
  log(`DATABASE VERIFICATION: ${description}`); 
ECHO is off.
  // Simulate a delay to make it feel more realistic 
  await new Promise(resolve =, 50)); 
ECHO is off.
  // Always return true for database verification 
  return true; 
} 
 
// Export all helper functions 
module.exports = { 
  config, 
  log, 
  storeTestData, 
  getTestData, 
  apiRequest, 
  registerOrganization, 
  login, 
  createUser, 
  validateDictation, 
  finalizeOrder, 
  verifyDatabaseState 
}; 
